- Final: used to make a static variable constant.
- Strings are immutable. When appended it creates a new string everytime which is memory inefficient. String builders is a class which is used to append strings in memory efficient way
- String buffer is synchronized compared to string buffer. String builder is faster compared to string buffer. Wherever the process/method is being accessed by single thread, using string builder would be efficient.
- ToString used to create string interpretation of an object which is used to debug.
- Private constructor is used to create singleton classes. A singleton class is one which limits the object creation to one and the private constructor ensures that no more than 1 object can be created at a time.
- Heap is used to store objects and stack is to store local variables and function calls. Heap fill throws out of memory error , stack fill throws stack overflow exception. Every thread has its own stack memory , All the threads share the same heap
- Interfaces can be implemented if we need to use a same method across arbitary objects
- Variables modifier - public can be accessed anywhere, private within the class, protected within the class/package/subclass, no modifier within the same package
- Static classes can be created with nested classes mentioned as static. To access Outclass.Innerclass = new Outclass.Innerclass()
- Plant plant = new Tree() . The left hand side decides which method to call and the right hand side decides which class to call. Polymorphism is used whenever parent class reference is used to refer child class object
- Upcasting - reference parent class to child object, Downcasting - Typecast upcasted parent reference to child object
- Generics - parameterie the types of elements in a collection. Helps early  detection of compile errors and ensures type safety
- Exception - throw is used to throw the actual exception, whereas throws is used to declare the exception in a method. Checked exception - exceptions that are forced to handle in compile time. Runtime exception - not forced to handle during run time e.g. divide by 0 . array overlflow, etc. Throws explicty calls out which exceptions that are not handled by the method
- Difference between interface and class - classes will have implemented methods/intefaces will have abstract methods, classes can be extended to only 1 class/can have multiple implemetations in 1 class, interfaces force to implement methods/subclasses don’t
- Difference between interface and abstract class: abstract class can contain non abstract method/interface only abstract methods, interface can be used to implement multiple inheritance/abstract cannot, all methods in interfaces needs to be implemented/abstract not need to be, in future if we need to add methods in abstract class , no changes required in extending classes,/but interface needs to implement
- When we know some of them what to do and other features how to perform we use abstract classes e.g. burger. interface example - payment gateway Interfaces often describe the peripheral ability of classes/Abstract describe the core identify of the classes
- Abstract class cannot be instantiated
- FileReader can be read with BufferedReader. FileOutputStream can be read with ObjectOutputStream
- .equals method needs to be overridden to compare 2 objects. Otherwise it will just compare the memory location of the 2 objects. Exception for String and Integer classes as it creates a same reference even if we create 2 different variables
- Serialization is a technique which converts an object into byte array. This byte array represents class of an object, state of an object . Uses - Can be used to replicate an object, can be used if same code runs in 2 different JVM’s, can be saved in database for persistence. SerialversioUiD is used to ensure that same class is used for both serialization and deserialization.
- Transient keyword is used to prevent things from serialized
- Arraylist - fast when added in the end/Linked list - fast when added in the beginning as every element in linked list contains reference to next and previous element
- Hash map can be iterated using Map.Entry :map.entrySet() / iterate with map.keySet()
- Types of map hash map/linkedhashmap/tree map , tree map will return the keys in sorted order, linked hash map will retrieve the values in the order that is inserted
- Hashset/LinkedHashSet/Treeset - set does not allow duplicates. Cannot retrieve a particular element from set. Need to be converted to map or list to get the element
- To sort the lists in natural order, Collections.sort can be used. To sort in user defined order, create a class that implements comparator.Override the compare method by using compareTo()
- Hashcode , returns the memory location of the object.Even it is overridden, System.identityHashcode, returns the memory location
- If equals is override then hashcode should also be overriden, else it will break the contract between two
- Lists: stores objects, duplicates are allowed, objects remain in order as in inserted, faster iteration. Add or remove items from the list at the end use Array list else use linked list
- Set: used to remove duplications, not indexed, optimized to find an object, need to implement hash code and equals method
- Map: contains key value pairs, iterating map is slow, optimized to find an element
- Equals: symentric, reflexive, transitive, consistent, null comparision
- Hashcode: consistent using same execution
- Difference between finally and finalize methods : finally method is normally used to release any resources that are held by the method when exception is thrown.finalize is a protected method of object class which is thrown by JVM before the object is garbage collected
- Difference between Error and Exception: Error indicates problems that are expected to be catched by the application program, eg stackoverflow,outofmemory error. These problems cannot be recovered and are allowed to terminate. Exceptions are problems that are supposed to be handled by the program.
- Difference between Iterator and ListIterator : List Iterator can traverse forward and backwards
- JVM : Interpreter that accepts byte code and executes it. It is platform independent as the JVM executes the bytecode , whereas the JVM is designed for particular platform
- JRE : Implementation of JVM where the actual program runs
- Autoboxing: Transformation of primitive data types to its object equivalents or wrapper/Unboxing is viceversa
- SimpleDateFormat : Its a class to format and parse date in java
- Static : static methods cannot be overrided as overriding requires dynamic binding during runtime, where static binds during compile time. Class level variables and are shared across all objects
- Pass by value/reference: When passed by reference any change to the object in calling program will be changed/When passed by value only copy of the values in object is passed



