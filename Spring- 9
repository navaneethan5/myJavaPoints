- Basic jars: spring core, context, beans.
- Spring bean container: Application context = new FileSytemApplicationContext("beans.xml");   Person person = (Person)context.getBean("person");
- Types of context: FileSystemApplicationContext, ClasspathApplicationContext.
- Constructor arguments: can be configured to bean by adding "insert constructor-arg element" option.
- Property elements: can be configured to bean by adding "insert property element".
- Dependency injection: if an object1 requires another object2, then the object2 can be injected to the object1. To do this , create a setmethod and set the ref bean in object1
- Singleton bean scope: irrespective of no of times it is requested from the bean container it will give the same bean.
- Prototype bean scope: everytime a bean is requested from the container it gives a different bean.
- Init method: Method runs after all propeties are set(construtor runs before)
- Destroy method: Method runs when closing the bean context(if prototype is set, then the close method needs to be taken care by user)
- List property: List property can be added by using "insert list, insert value  element"; set property also same instead set cannot have duplicate values.
- List of beans: List of beans can be added by using "insert list, insert ref element"
- Inner beans: Instead of setting the property as bean, we can define the bean.
- Map property: Map property can be added by using "insert props, insert prop" element
- Map of beans: Map property can be added by using "insert map, insert entry" element.To use object as a key, we need to implement hashcode and .equals method.
- Auto wiring: Tells spring how to figure out the dependencies between beans and wire automatically.
- Bean setters : Whenever there is a dependency, we need to add the corresponding setter object to inject the beans and add corresponding entry in bean.xml
- Autowiring by type: Set the autowire property to "byType". Need to ensure that there are no ambiguites.
- Autowiring by name: Use this property when ambuguities present. Can be set by using "byName". Ensure the bean name matches with the property.
- Autowiring by constructor: Works in the same way as "byType" so it should not be ambigiuous. 
- Default autowiring: Can be done by setting the default type at beans.xml level. Using default-autowired candidates will ensure that only mentioned beans can be autowired.
- Autowire candidate/Primary: Candidate - setting autowired candidate to false , will ignore any ambiguties error.Primary - set to true to take the bean as primary and other beans can be autowired some where else.
- Annotations enabling: Add the context namespace in beans xml; Add <context:annotatation-config> tag;
- Annotation autowiring: Add the @Autowired in the setter method/constructor method/declaration section(setter not needed) of the DI object
- Required property; If required property of autowired is set to false, then the corresponding beans xml entry is not needed, but null check needs to be made wherever the beans are used.
- Qualifer tag: If there are bean ambiguities, then set the qualifier for one of the bean- insert qualifier/class level @Qualfier() , and use the @Qualifier() in class along with @Autowire.(similar to primary). 
- Resource tag: Use @Resource(name="") to autowire the bean
- Init/Destroy annotation: Use @Resource. Then create methods @PostConstruct and @PreDestroy
- Inject annotattion: Include javax.inject jar. Then use @Inject along with @Named(value="").
- Automatic Bean Discovery: Eliminate the bean.xml entires by adding <context:componenent-scan> with baepackage path. Then add @Component to all class level beans.
- Setting property with annotation: Use the @Autowired in setter method and pass in the value along with @Value("").
- SPEL: Can be used to set the dynamic values of properties in a bean. Try with #{} to set the bean values.
- SPEL annotations: In the value operator of the setter method give "#{}"
- Sample SPEL usages:#{new java.util.Date.toString}, #{T(Math).PI}
- Property files: Property files can be accessed by using <context:property-placeholder> and metioning the location of the property file. Then access the property values in the bean using ${} in the property.
- Basic connection pooling: Download sql-jdbc connector and use Driver.class. Then download apache dbcp and use BasicDataSource. Create a bean entry dataSource with class BasicDataSource. Then set the properties, driverClassName,url, username, password
- JDBCTemplate: A class used to query the database. Can be downloaded from spring jdbc jar. To cofigure it, create a setter method for datasource and wrap with JDBCTemplate constructor.
- NamedParameterJdbcTemplate: Use :<parm name> for queries. For that use MapSqlParameterSource class to add params with key and value.
- BeanPropertySqlParamertSource: This is an alternative for MapSqlParameterSource which can be used to add all properties in the beans as params.
- Batchupdate: Can be done by using jdbc.batchUpdate. The sql statement is prepared by SqlParameterSource parms = SqlParameterSourceUtils.createBatch(list1.toArray());
- Transaction Management: Create a bean with DataSourceTransactionManager and define a property "dataSource" .Then add <tx:annotation-driven>.
- Apply Transactions: Add @Transactional to ensure the rollback happens in terms of any failures.
- Web jars: Add spring web and spring web mvc
- Dispatcher servelet: Spring roots all request through dispatcher servelet -> which in turn look for controller. Can be created by using new servelet with class pointing DispatcherServelet.The config is in web.xml
- Load on startup: Use <load-on-startup> to 1 for loading when server starts. The spring bean configuration file "beans.xml" should be in web-inf folder with name <servelet-name>-servelet.xml
- Controller: Add annotation @Controller. Add controller methods with annotation @RequestMapping("")
- Controller annotation: Add <mvc:annotation-driven> instead of <context:annotation-driven>
- View Resolver: Used to convert strings to jsps. Create a bean with class InternalResourceviewResolver with properties prefix- /WEB-INF/jsps/ and suffix - .jsp
- Http Session: HttpSession class can be used with params of any controller method. Value can be set by using session.setAttubute(key, value). In jsp it can be accessed by using <%= %>
- Model: Model class can be used with parms of any controller method. Value can be set by using model.addAttribute(key,value). In jsp it can be accessed by using SPEL ${key}
- JSTL: Add JSTL jar and JSTL tag libarary import needs to be added before using JSTL tags.
- Cout tag: Cout tag escapes the special chars.
- JNDI: Java Naming Directory Interface; Add a resource bean config in tomcat context.xml. Then add the ref in web.xml
- JSTL Sql: Can be configured by adding jstl library for sql in jsp. Then use <sql:query var="rs" dataSource="jdbc/spring">
- Loading Beans: To load other beans like Dao-beans and Service beans, create a listerer tag with <listener-class> ..ContextLoaderListerner. Then add <context-parms> with <param-name> as contextConfigLocation; <param-value> classpath: <bean path>
- Configure JNDI: Create a <jee:jndi-lookup> with id dataSource and class DataSource. Use the jndi-name with jdbc/spring
- Service: Can be aded by using @Service
- JSP nav: On click of link if it needs to be navigated to different request, then use pageContext.request.contextConfig/<request mapping>
- Set URL params: Pass the variable in the method parms(). The value can be set by using @RequestParms("<name>")




Open ques:
what is factory bean and method
what is connection pooling
