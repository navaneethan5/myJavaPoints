- Threads can be created by either extending Thread class or implementing Runnable interface
- To avoid the caching issue when the variable is shared by 2 thread i.e. 1 thread updates and other reads, use volatile keyword 
- Join method actually waits till the thread exception is complete
- Thread interleaving issue occurs when 2 threads trying to update a shared variable. Synchronized keyword is used to resolve the issues, as it helps the thread 1 to acquire intrinsic lock while the other waits to be released
- Another way of fixing thread interleaving issue is to use synchronized code blocks by creating separate objects to acquire intrinsic lock
- Thread pool can be created by defining an object of type ExecutorService and instantiating to newFixedThreadPool. submit method will submit all the tasks. Shutdown method will be called once all tasks are submitted. awaitTermination() method will be called till all the threads are complete
- Countdown latch is a thread safe class which is used to resolve thread synchronization problem.It decrements untill the count down is complete, the latch.await method is called
- Arrayblockingqueue is a best example of thread syncronisation, where put methods adds the value to the queue and take method takes the value from the queue
- Wait & notify is a mechanism to hold the thread execution until a condition is satisfied. Both wait and notify should be inside the synchronized block
- Reentrant lock is a thread lock mechanism using lock and unlock calls before and after the method
- Deadlock:  Occurs when thread1 is waiting for an object lock which is acquired by thread2 and vice versa.Can be eliminated by using ReentrantLock class
- Semaphore: Its class with incremental/decremental number which is used to acquire lock/release lock. The acquire method will acquire a lock and release method will release the lock. Its is mainly used to control the simultaneous users of a shared resource unto a maximum number.
- Mutex: Having a single thread accessing the resource at one time
- Thread safe: If a method/instance is able to be executed by several threads without any issues
- Thread choice: Runnable is preffered as we do not need to create an objects , can be implemented along with mutiple interfaces
- Monitor: Each object reference has a monitor which ensures that only one thread executes the synchronized block
