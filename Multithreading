- Threads: Can be created by either extending Thread class or implementing Runnable interface
- Volatile: To avoid the caching issue when the variable is shared by 2 thread i.e. 1 thread updates and other reads, use volatile keyword 
- Join:  Join method actually waits till the thread exception is complete
- Synchronized: Thread interleaving issue occurs when 2 threads trying to update a shared variable. Synchronized keyword is used to resolve the issues, as it helps the thread 1 to acquire intrinsic lock while the other waits to be released
- Synchronized code block: Another way of fixing thread interleaving issue is to use synchronized code blocks by creating separate objects to acquire intrinsic lock
- Thread pool: Can be created by defining an object of type ExecutorService and instantiating to newFixedThreadPool. submit method will submit all the tasks. Shutdown method will be called once all tasks are submitted. awaitTermination() method will be called till all the threads are complete
- Countdown latch: Its a thread safe class which is used to resolve thread synchronization problem.It decrements untill the count down is complete, the latch.await method is called
- Arrayblockingqueue: Best example of thread syncronisation, where put methods adds the value to the queue and take method takes the value from the queue
- Wait & notify: Its a mechanism to hold the thread execution until a condition is satisfied. Both wait and notify should be inside the synchronized block
- Reentrant lock: Its a thread lock mechanism using lock and unlock calls before and after the method
- Deadlock:  Occurs when thread1 is waiting for an object lock which is acquired by thread2 and vice versa.Can be eliminated by using ReentrantLock class
- Semaphore: Its class with incremental/decremental number which is used to acquire lock/release lock. The acquire method will acquire a lock and release method will release the lock. Its is mainly used to control the simultaneous users of a shared resource unto a maximum number.
- Mutex: Having a single thread accessing the resource at one time
- Thread safe: If a method/instance is able to be executed by several threads without any issues
- Thread choice: Runnable is preffered as we do not need to create an objects , can be implemented along with mutiple interfaces
- Monitor: Each object reference has a monitor which ensures that only one thread executes the synchronized block
- Difference between wait/sleep - wait is at object level/sleep is at class level, wait releases the lock/sleep doesnt, wait is used for interthread communication/sleep is to pause the process
- Best practices: Minimize scope of syncronization, prefer volatile over synchronization, Use high level concurreny utilities such as Blocking queue, Semaphore, CountdownLatch instead of wait/notigy for inter thread communication,prefer concurrent collection over synchronized collection for better scalablity.
- Concurrent/synchronized collections: Collections such as hashmap,linkedhashmap are slower as the synchronized blocks the entire block/Concurenthashmap divides the map into different segments and locks only on segments, thereby allowing multiple thread to access otehr segments

